import { useState, useEffect, useRef, useCallback } from 'react';
import { animateExpansion, animateShrink } from '../utils/animations';

const SPOTLIGHT_ANIMATION_DELAY = 300;
const SPOTLIGHT_DURATION = 6000;
const TRANSITION_DELAY = 400;
const DIMMING_DELAY = 150;
const SCROLL_DURATION = 600; // How long to wait for scroll to complete
const SMOOTH_SCROLL_DURATION = 2000; // Duration of smooth scroll animation

export function useSpotlight(items, containerRef) {
  const [spotlightIndex, setSpotlightIndex] = useState(0);
  const [isSpotlighting, setIsSpotlighting] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [autoFocus, setAutoFocus] = useState(true);
  const [autoScroll, setAutoScroll] = useState(true);
  const [scrollSpeed, setScrollSpeed] = useState(6000); // milliseconds between articles

  const spotlightRunIdRef = useRef(0);
  const spotlightIndexRef = useRef(0); // Use ref to avoid closure issues
  const isPausedRef = useRef(false); // Use ref to avoid stale closure issues
  const autoFocusRef = useRef(true); // Use ref to avoid stale closure issues
  const autoScrollRef = useRef(true); // Use ref to avoid stale closure issues
  const scrollSpeedRef = useRef(6000); // Use ref to avoid stale closure issues
  const scrollAnimationRef = useRef(null); // Track ongoing scroll animation
  const timersRef = useRef({
    dimming: null,
    spotlightApply: null,
    spotlight: null,
    nextSpotlight: null
  });
  const animationsRef = useRef({
    expand: null,
    shrink: null
  });
  
  // Keep refs in sync with state
  useEffect(() => {
    spotlightIndexRef.current = spotlightIndex;
  }, [spotlightIndex]);

  useEffect(() => {
    isPausedRef.current = isPaused;
  }, [isPaused]);

  useEffect(() => {
    autoFocusRef.current = autoFocus;
  }, [autoFocus]);

  useEffect(() => {
    autoScrollRef.current = autoScroll;
  }, [autoScroll]);

  useEffect(() => {
    scrollSpeedRef.current = scrollSpeed;
  }, [scrollSpeed]);

  const clearTimers = useCallback(() => {
    Object.values(timersRef.current).forEach(timer => {
      if (timer) clearTimeout(timer);
    });
    timersRef.current = {
      dimming: null,
      spotlightApply: null,
      spotlight: null,
      nextSpotlight: null
    };

    if (animationsRef.current.expand) {
      animationsRef.current.expand.cancel();
      animationsRef.current.expand = null;
    }
    if (animationsRef.current.shrink) {
      animationsRef.current.shrink.cancel();
      animationsRef.current.shrink = null;
    }
    
    // Cancel any ongoing scroll animation
    if (scrollAnimationRef.current) {
      cancelAnimationFrame(scrollAnimationRef.current);
      scrollAnimationRef.current = null;
    }
  }, []);

  const resetSpotlightState = useCallback(({ resetIndex = false } = {}) => {
    clearTimers();
    setIsSpotlighting(false);
    if (resetIndex) {
      spotlightIndexRef.current = 0;
      setSpotlightIndex(0);
    }
  }, [clearTimers]);

  const spotlightNextItem = useCallback(() => {
    if (isPausedRef.current || !containerRef?.current) {
      console.log('[Spotlight] Paused or no container');
      return;
    }

    // If auto-scroll is on but auto-focus is off, just scroll without spotlight
    if (autoScrollRef.current && !autoFocusRef.current) {
      const items = containerRef.current.querySelectorAll('.feed-item');
      if (items.length === 0) {
        console.log('[Spotlight] No items found');
        return;
      }

      const currentIndex = ((spotlightIndexRef.current % items.length) + items.length) % items.length;
      const nextIndex = (currentIndex + 1) % items.length;
      const nextItem = items[nextIndex];
      
      console.log(`[Spotlight] Auto-scrolling to item ${nextIndex + 1}/${items.length}`);
      
      // Cancel any existing scroll animation
      if (scrollAnimationRef.current) {
        cancelAnimationFrame(scrollAnimationRef.current);
        scrollAnimationRef.current = null;
      }
      
      const container = containerRef.current;
      const containerRect = container.getBoundingClientRect();
      const itemRect = nextItem.getBoundingClientRect();
      const targetScrollTop = container.scrollTop + (itemRect.top - containerRect.top) - 20;
      
      // Update index immediately
      spotlightIndexRef.current = nextIndex;
      setSpotlightIndex(nextIndex);
      
      // Custom smooth scroll animation
      const startScrollTop = container.scrollTop;
      const scrollDistance = targetScrollTop - startScrollTop;
      const startTime = performance.now();
      
      const smoothScroll = (currentTime) => {
        if (isPausedRef.current || !autoScrollRef.current) {
          return;
        }
        
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / SMOOTH_SCROLL_DURATION, 1);
        
        // Cubic ease-in-out
        const easeProgress = progress < 0.5
          ? 4 * progress * progress * progress
          : 1 - Math.pow(-2 * progress + 2, 3) / 2;
        
        const currentScrollTop = startScrollTop + (scrollDistance * easeProgress);
        container.scrollTop = currentScrollTop;
        
        if (progress < 1) {
          scrollAnimationRef.current = requestAnimationFrame(smoothScroll);
        } else {
          // Animation complete
          scrollAnimationRef.current = null;
          if (!isPausedRef.current && autoScrollRef.current) {
            timersRef.current.spotlight = setTimeout(() => {
              spotlightNextItem();
            }, Math.max(0, scrollSpeedRef.current - SMOOTH_SCROLL_DURATION));
          }
        }
      };
      
      scrollAnimationRef.current = requestAnimationFrame(smoothScroll);
      return;
    }

    // If auto-focus is required but off, don't proceed
    if (!autoFocusRef.current) {
      return;
    }

    const items = containerRef.current.querySelectorAll('.feed-item');
    if (items.length === 0) {
      console.log('[Spotlight] No items found');
      return;
    }

    // Use ref to get current index (avoids stale closure issues)
    const currentIndex = ((spotlightIndexRef.current % items.length) + items.length) % items.length;
    const currentItem = items[currentIndex];
    
    console.log(`[Spotlight] Starting spotlight for item ${currentIndex + 1}/${items.length}`);

    if (!currentItem) {
      spotlightIndexRef.current = 0;
      setSpotlightIndex(0);
      return;
    }

    const runId = ++spotlightRunIdRef.current;
    clearTimers();

    // Reset all items
    items.forEach(item => {
      item.classList.remove('spotlight', 'dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
      item.style.transition = '';
      item.style.paddingTop = '';
      item.style.paddingRight = '';
      item.style.paddingBottom = '';
      item.style.paddingLeft = '';
      item.style.maxHeight = '';
      item.style.marginTop = '';
      item.style.marginBottom = '';
      item.style.transform = '';
    });

    // Scroll the item to the top of the container first (if auto-scroll is enabled)
    const scrollToItem = () => {
      if (!autoScrollRef.current) return Promise.resolve();
      
      return new Promise((resolve) => {
        const container = containerRef.current;
        const containerRect = container.getBoundingClientRect();
        const itemRect = currentItem.getBoundingClientRect();
        
        // Calculate scroll position to put item at top of container with 20px padding
        const targetScrollTop = container.scrollTop + (itemRect.top - containerRect.top) - 20;
        
        // Use scrollend event when available, fallback to timeout
        let scrollComplete = false;
        
        const handleScrollEnd = () => {
          if (scrollComplete) return;
          scrollComplete = true;
          container.removeEventListener('scrollend', handleScrollEnd);
          console.log('[Spotlight] Scroll completed');
          resolve();
        };
        
        // Modern browsers support scrollend event
        if ('onscrollend' in window) {
          container.addEventListener('scrollend', handleScrollEnd);
        } else {
          // Fallback: check if scroll has stopped
          let lastScrollTop = container.scrollTop;
          let scrollCheckCount = 0;
          
          const checkScrollComplete = () => {
            const currentScrollTop = container.scrollTop;
            if (Math.abs(currentScrollTop - lastScrollTop) < 1) {
              scrollCheckCount++;
              if (scrollCheckCount >= 3) { // Scroll has been stable for 3 checks
                handleScrollEnd();
                return;
              }
            } else {
              scrollCheckCount = 0;
              lastScrollTop = currentScrollTop;
            }
            setTimeout(checkScrollComplete, 50);
          };
          
          setTimeout(checkScrollComplete, 100);
        }
        
        // Fallback timeout in case scrollend doesn't fire
        setTimeout(() => {
          if (!scrollComplete) {
            handleScrollEnd();
          }
        }, SCROLL_DURATION);
        
        // Perform the scroll
        console.log(`[Spotlight] Scrolling to position ${targetScrollTop}`);
        container.scrollTo({
          top: targetScrollTop,
          behavior: 'smooth'
        });
      });
    };
    
    // Execute scroll and then spotlight
    if (autoScrollRef.current) {
      scrollToItem().then(() => {
        if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;

      requestAnimationFrame(() => {
        if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;

        // Dim other items
        timersRef.current.dimming = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
          requestAnimationFrame(() => {
            items.forEach(item => {
              if (item !== currentItem) {
                item.classList.add('dimmed');
              }
            });
          });
        }, DIMMING_DELAY);

        // Apply spotlight with expansion animation
        timersRef.current.spotlightApply = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
          requestAnimationFrame(() => {
            // Apply staggered push animations
            items.forEach((item, index) => {
              if (item === currentItem) return;
              const distance = Math.abs(index - currentIndex);
              if (index < currentIndex) {
                if (distance === 1) item.classList.add('push-up-1');
                else if (distance === 2) item.classList.add('push-up-2');
                else if (distance === 3) item.classList.add('push-up-3');
              } else {
                if (distance === 1) item.classList.add('push-down-1');
                else if (distance === 2) item.classList.add('push-down-2');
                else if (distance === 3) item.classList.add('push-down-3');
              }
            });

            // Expand animation
            animationsRef.current.expand = animateExpansion(currentItem);
            currentItem.classList.add('spotlight');
            setIsSpotlighting(true);
          });
        }, SPOTLIGHT_ANIMATION_DELAY);

        // Shrink and move to next
        timersRef.current.spotlight = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;

          requestAnimationFrame(() => {
            const shrinkAnim = animateShrink(currentItem);
            
            if (!shrinkAnim) {
              // If animation failed, proceed anyway
              currentItem.classList.remove('spotlight');
              items.forEach(item => {
                item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
              });
              setIsSpotlighting(false);
              const nextIndex = (currentIndex + 1) % items.length;
              spotlightIndexRef.current = nextIndex;
              setSpotlightIndex(nextIndex);
              
              timersRef.current.nextSpotlight = setTimeout(() => {
                if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
                requestAnimationFrame(() => {
                  spotlightNextItem();
                });
              }, TRANSITION_DELAY);
              return;
            }
            
            // Store animation reference
            animationsRef.current.shrink = shrinkAnim;
            
            // Set up animation event handler
            const finishHandler = () => {
              if (isPausedRef.current) {
                console.log('[Spotlight] Aborting - paused');
                animationsRef.current.shrink = null;
                return;
              }

              // Get fresh items and calculate next index
              const freshItems = containerRef.current?.querySelectorAll('.feed-item');
              if (!freshItems || freshItems.length === 0) {
                console.log('[Spotlight] No items found, aborting');
                animationsRef.current.shrink = null;
                return;
              }

              const nextIndex = (currentIndex + 1) % freshItems.length;
              console.log(`[Spotlight] Shrink complete. Next index: ${nextIndex + 1}/${freshItems.length}`);
              
              // Clear animation reference
              animationsRef.current.shrink = null;
              
              requestAnimationFrame(() => {
                requestAnimationFrame(() => {
                  currentItem.classList.remove('spotlight');
                  freshItems.forEach(item => {
                    item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
                  });
                  setIsSpotlighting(false);

                  // Update both ref and state
                  spotlightIndexRef.current = nextIndex;
                  setSpotlightIndex(nextIndex);
                  
                  console.log(`[Spotlight] Setting up next spotlight in ${TRANSITION_DELAY}ms`);
                  
                  // Clear any existing nextSpotlight timer
                  if (timersRef.current.nextSpotlight) {
                    clearTimeout(timersRef.current.nextSpotlight);
                  }
                  
                  timersRef.current.nextSpotlight = setTimeout(() => {
                    // Check if we're still not paused and have items (use current state, not closure)
                    if (!containerRef?.current) {
                      console.log('[Spotlight] Next spotlight aborted - no container');
                      return;
                    }
                    
                    // Double-check we have items
                    const checkItems = containerRef.current.querySelectorAll('.feed-item');
                    if (!checkItems || checkItems.length === 0) {
                      console.log('[Spotlight] Next spotlight aborted - no items');
                      return;
                    }
                    
                    console.log(`[Spotlight] Triggering next spotlight cycle`);
                    requestAnimationFrame(() => {
                      spotlightNextItem();
                    });
                  }, TRANSITION_DELAY);
                });
              });
            };

            shrinkAnim.onfinish = () => {
              console.log('[Spotlight] Animation finished');
              finishHandler();
            };
            
            shrinkAnim.oncancel = () => {
              animationsRef.current.shrink = null;
            };
          });
        }, scrollSpeedRef.current);
      });
    } else {
      // If auto-scroll is off, spotlight immediately
      requestAnimationFrame(() => {
        if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;

        // Dim other items
        timersRef.current.dimming = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
          requestAnimationFrame(() => {
            items.forEach(item => {
              if (item !== currentItem) {
                item.classList.add('dimmed');
              }
            });
          });
        }, DIMMING_DELAY);

        // Apply spotlight animation
        timersRef.current.spotlightApply = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
          requestAnimationFrame(() => {
            // Expand animation
            animationsRef.current.expand = animateExpansion(currentItem);
            currentItem.classList.add('spotlight');
            setIsSpotlighting(true);
          });
        }, SPOTLIGHT_ANIMATION_DELAY);

        // Shrink and move to next
        timersRef.current.spotlight = setTimeout(() => {
          if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;

          requestAnimationFrame(() => {
            const shrinkAnim = animateShrink(currentItem);
            
            if (!shrinkAnim) {
              // If animation failed, proceed anyway
              currentItem.classList.remove('spotlight');
              items.forEach(item => {
                item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
              });
              setIsSpotlighting(false);
              const nextIndex = (currentIndex + 1) % items.length;
              spotlightIndexRef.current = nextIndex;
              setSpotlightIndex(nextIndex);
              
              timersRef.current.nextSpotlight = setTimeout(() => {
                if (runId !== spotlightRunIdRef.current || isPausedRef.current) return;
                requestAnimationFrame(() => {
                  spotlightNextItem();
                });
              }, TRANSITION_DELAY);
              return;
            }
            
            // Store animation reference
            animationsRef.current.shrink = shrinkAnim;
            
            // Set onfinish handler immediately after getting animation
            // Use a flag to prevent multiple calls
            let handlerCalled = false;
            
            const finishHandler = () => {
              if (handlerCalled) {
                console.log('[Spotlight] Handler already called, ignoring duplicate');
                return;
              }
              handlerCalled = true;
              
              console.log('[Spotlight] Shrink onfinish handler called');
              
              // Check if we should proceed (use ref for current value)
              if (isPausedRef.current) {
                console.log('[Spotlight] Aborting - paused');
                animationsRef.current.shrink = null;
                return;
              }

              // Get fresh items and calculate next index
              const freshItems = containerRef.current?.querySelectorAll('.feed-item');
              if (!freshItems || freshItems.length === 0) {
                console.log('[Spotlight] No items found, aborting');
                animationsRef.current.shrink = null;
                return;
              }

              // Clean up current spotlight
              currentItem.classList.remove('spotlight');
              freshItems.forEach(item => {
                item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
              });
              setIsSpotlighting(false);
              animationsRef.current.shrink = null;
              
              // Move to next item
              const nextIndex = (currentIndex + 1) % freshItems.length;
              spotlightIndexRef.current = nextIndex;
              setSpotlightIndex(nextIndex);
              
              console.log(`[Spotlight] Triggering next spotlight cycle`);
              requestAnimationFrame(() => {
                spotlightNextItem();
              });
            };

            shrinkAnim.onfinish = () => {
              console.log('[Spotlight] Animation finished');
              finishHandler();
            };
            
            shrinkAnim.oncancel = () => {
              animationsRef.current.shrink = null;
            };
          });
        }, scrollSpeedRef.current);
      });
    }
  }, [containerRef, clearTimers]); // Using refs for isPaused and spotlightIndex to avoid stale closures

  const pauseSpotlight = useCallback(() => {
    clearTimers();
    setIsPaused(true);
  }, [clearTimers]);

  const resumeSpotlight = useCallback(() => {
    setIsPaused(false);
    if (items.length > 0) {
      requestAnimationFrame(() => {
        spotlightNextItem();
      });
    }
  }, [items.length, spotlightNextItem]);

  const navigateToItem = useCallback((direction) => {
    if (!containerRef?.current) return;
    
    const items = containerRef.current.querySelectorAll('.feed-item');
    if (items.length === 0) return;
    
    const currentIndex = ((spotlightIndexRef.current % items.length) + items.length) % items.length;
    const currentItem = items[currentIndex];
    
    // If there's a current spotlight item, shrink it first
    if (currentItem && currentItem.classList.contains('spotlight')) {
      const shrinkAnim = animateShrink(currentItem);
      if (shrinkAnim) {
        animationsRef.current.shrink = shrinkAnim;
        shrinkAnim.onfinish = () => {
          // Clean up current spotlight
          currentItem.classList.remove('spotlight');
          items.forEach(item => {
            item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
          });
          setIsSpotlighting(false);
          animationsRef.current.shrink = null;
          
          // Now navigate to next/prev
          clearTimers();
          setIsPaused(false);
          
          if (direction === 'next') {
            const nextIdx = (spotlightIndexRef.current + 1) % items.length;
            spotlightIndexRef.current = nextIdx;
            setSpotlightIndex(nextIdx);
          } else {
            const prevIdx = (spotlightIndexRef.current - 1 + items.length) % items.length;
            spotlightIndexRef.current = prevIdx;
            setSpotlightIndex(prevIdx);
          }
          
          requestAnimationFrame(() => {
            spotlightNextItem();
          });
        };
      } else {
        // If animation failed, proceed anyway
        currentItem.classList.remove('spotlight');
        items.forEach(item => {
          item.classList.remove('dimmed', 'push-up-1', 'push-up-2', 'push-up-3', 'push-down-1', 'push-down-2', 'push-down-3');
        });
        setIsSpotlighting(false);
        clearTimers();
        setIsPaused(false);
        
        if (direction === 'next') {
          const nextIdx = (spotlightIndexRef.current + 1) % items.length;
          spotlightIndexRef.current = nextIdx;
          setSpotlightIndex(nextIdx);
        } else {
          const prevIdx = (spotlightIndexRef.current - 1 + items.length) % items.length;
          spotlightIndexRef.current = prevIdx;
          setSpotlightIndex(prevIdx);
        }
        
        requestAnimationFrame(() => {
          spotlightNextItem();
        });
      }
    } else {
      // No current spotlight, just navigate
      clearTimers();
      resetSpotlightState();
      setIsPaused(false);
      setIsSpotlighting(false);
      
      if (direction === 'next') {
        const nextIdx = (spotlightIndexRef.current + 1) % items.length;
        spotlightIndexRef.current = nextIdx;
        setSpotlightIndex(nextIdx);
      } else {
        const prevIdx = (spotlightIndexRef.current - 1 + items.length) % items.length;
        spotlightIndexRef.current = prevIdx;
        setSpotlightIndex(prevIdx);
      }
      
      requestAnimationFrame(() => {
        spotlightNextItem();
      });
    }
  }, [items.length, clearTimers, resetSpotlightState, spotlightNextItem, containerRef]);

  // Start spotlight cycle when items are loaded
  useEffect(() => {
    if (items.length > 0 && !isPaused) {
      const timer = setTimeout(() => {
        spotlightNextItem();
      }, 500);
      return () => clearTimeout(timer);
    }
  }, [items.length, isPaused, spotlightNextItem]);

  // Cleanup on unmount
  useEffect(() => {
    return () => {
      clearTimers();
    };
  }, [clearTimers]);

  return {
    spotlightIndex,
    isSpotlighting,
    isPaused,
    autoFocus,
    autoScroll,
    scrollSpeed,
    setAutoFocus,
    setAutoScroll,
    setScrollSpeed,
    pauseSpotlight,
    resumeSpotlight,
    navigateToItem,
    resetSpotlightState
  };
}

